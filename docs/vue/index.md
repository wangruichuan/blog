## 阅读官网文档

该看 模版语法

## Vue能干什么
- 无需构建步骤，渐进式增强静态的 HTML
- 在任何页面中作为 Web Components 嵌入
- 单页应用 (SPA)
- 全栈 / 服务端渲染 (SSR)
- Jamstack / 静态站点生成 (SSG)
- 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面

### Vue速度快吗？

Vue 3 是性能最强的主流前端框架之一，可以轻松处理大多数 web 应用的场景，并且几乎不需要手动优化。

跑分方面，Vue 在 js-framework-benchmark 中的表现比 React 和 Angular 要好得多。在该基准测试中，它还与一些生产环境下最快级别的非虚拟 DOM 框架并驾齐驱。

请注意，像上面这样的跑分的侧重点在于原始渲染性能在特定情况下的优化，因此不能完全代表真实世界的性能结果。如果你更关心页面加载性能，欢迎用 WebPageTest 或是 PageSpeed Insights 来测试本站。本文档站是一个完全由 Vue 本身构建，通过静态生成预渲染，并在客户端进行 hydration 的单页应用。它在模拟 4 倍 CPU 降速的 Moto G4 + 低速 4G 网络的情况下依然能获得 100 分的性能得分。

你可以在渲染机制章节了解更多关于 Vue 如何自动优化运行时性能的信息，也可以在性能优化指南中了解如何在特别苛刻的情况下优化 Vue 应用。

## vue在线挑战集合

一个Vue在线挑战集合，像刷Leet Code一样学习Vue

https://cn-vuejs-challenges.netlify.app/

## 如何封装组件？
1. 确认动机。你为什么要去封装组件呢？
   - 比方说你这个界面太复杂了，我想减少页面复杂度
   - 很多个组件要用到同一个功能，我希望把这个功能给提出去，那这个组件就必须要具备一些通用性。当然，你的通用范围可能不同，你是在一系列项目模块中呢，还是在整个项目里，还是说我做成开源的。范围不同，后续设计也不一样
2. 分析边界。 简单来说，就是哪些事情组件要管，哪些事情组件不管，这个也是取决于你的动机。
   一般来说，越通用的组件，它实现的功能其实很少，边界越窄，你就能用在各种不一样的场景下，当然，带来的缺点就是便利性的降低，这也就是为什么要对一些UI组件的二次封装，来针对我们的业务进行一个封装。
3. 设计接口。属性、插槽、事件。写文档记得
4. 代码实现
5. 功能测试
6. 后续维护


## 模版到底是什么？

在这些诸多的问题里边，问题出的最多的就是这一块，就是“模版到底是个啥？”

```jsx
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>
```

如果你认为它是一个html 的话，那说明你在学习组件之前就出了很多问题，现在毒教材很多，受害者呢也很多，那么这个问题到底是啥呢？我首先请大家忘记之前学过的所有的vue，我现在给你下一个结论，你不能这些写。

![template](https://img.picgo.net/2025/07/26/image97e396121cc6546f.png)

我现在告诉你，做vue开发，你不能动```<div id='app'>```里的内容，你不能动这一块，这一块是vue要挂载的区域，它会把vue里边的界面，挂载到这个区域，简单来说就是替换，把vue生成的界面替换掉这个div，那么现在就出现了一个问题：替换成啥啊？你得告诉vue你到底要替换成啥啊，怎么告诉vue？

![render](https://img.picgo.net/2025/07/26/imagee3eb8503d6864c3a.png)

需要在vue配置里写一个render函数，这个render函数里边有个参数h，通过这个函数，你要返回一个结果，这个结果呢就是界面，那么vue到时候运行的时候，他就会调用这个函数，得到你返回的界面，然后用你这个界面去替换掉这个div，就这么简单。

![ui](https://img.picgo.net/2025/07/26/image75fe6e65fb5b4ad3.png)

但你要怎么写呢。你总不能直接自己手写个字符串吧，所以呢，这一块需要一个标准格式，vue能看懂的标准格式，那么这个标准格式怎么来的呢，就是通过参数h来生成，这个参数是一个函数，调用这个参数，可以生成一个对象，这个对象就是用来描述这个UI界面的，最终你需要把这个UI对象给返回.

那现在的问题是，调用这个函数的时候，我怎么告诉他我需要什么样的界面呢，他有这么几个参数：
1. 第一个是标签名
2. 第二个参数可以传一个对象，这个对象可以配置标签的属性等等
3. 第三个参数，你可以配置这个标签的子元素。子元素也是一个h函数


这个h函数看起来就有点类似```document.createElement```，我们看一下UI对象的打印结果就知道了。
![](https://img.picgo.net/2025/07/26/image4939e48f91e49797.png)

这个打印结果里边，它并没有打印出一个HTML元素，而是一个VNode对象，这只是一个**普通的JS对象**，这个对象里边有很多的属性，其中一个属性叫做tag，表示标签的名字，不管怎么样，这个对象，怎么看都不是一个dom元素，它只是一个**普通的JS对象**，我们把它叫做**虚拟dom**，他用一个普通的JS对象去描述界面，至于说vue为什么要这么做，是一些迫不得已的原因（个人理解最重要的原因是要支持跨端）。

但是我们注意到页面上最终生成出来的，确确实实是一个真实dom，你不能把对象显示到这，浏览器不认识啊，因此我们可以得出来一个结论：通过render函数返回一个虚拟dom，就是一个普通的js对象，把这个普通的js对象交给vue，然后呢vue把它变成一个真实的dom，然后把这个真实的dom替换掉挂载的元素，也就是这个div，这才是vue渲染界面的真正逻辑与流程，当然也只是一个非常简约的流程。

那接下来就好解释了，我们用h函数能不能去写界面？能写，写起来恶不恶心？恶心！所以呢，vue非常贴心的给你考虑到了，vue给你提供了一个template配置（字符串），这个字符串你可以按照一些特殊的语法来编写。那到时候，vue就帮你把这个玩意变成h函数，所以就不用再去写这个render了。但这个玩意只是为了让你写着方便的，最终其效果的还是render，只是帮你变成了render，这就叫**模版编译**。

![](https://img.picgo.net/2025/07/26/imageab33801ab59ee9f2.png)


甚至vue还支持你把模版写在html里（你要挂载的元素中），把这个元素的outerHTML字符串当做template，然后把这个template转成render。

所以说，我们在模版里写的这些语法，还有写的什么属性的绑定，还有写的什么事件，在真正运行的时候压根不存在，全是变成了render函数里的虚拟dom。

如果在工程化环境中呢，像这种sfc(单文件组件)里边的template是啥呢？还是一样的，只不过在工程化环境里，会直接在编译时直接就把模版变成render函数了（之前的模版编译发生在运行时，工程化时候直接在打包的时候就转换完了，性能更好，这种也叫做 **模版预编译**），最终还是要靠render起作用，从这个角度来看，不仅仅是模版，甚至一个组件，一个sfc，本质上也是普通的JS对象。

好，到现在，相信读者已经搞清楚了模版、render、虚拟dom这些的基本含义了，这对于理解后边的很多知识都是非常重要的。


## 全局注册 vs 局部注册

我们的代码是分散的，分散到不同的模块里边，最终一打包，就会变成一个文件，所有的模块都会变成一个文件。

![nHhmU.png](https://i.imgs.ovh/2025/07/28/nHhmU.png)

如果你这样的话，其实全局和局部注册没什么区别。

当你的项目上了一定规模之后，我们很有可能不希望打包成一个文件，我们需要分包。

那这样一来，如果你是局部注册的，就不会有问题，但如果你是全局注册的，全局注册的这些组件都是在main.js里注册的

（这里为什么一定要在main.js 注册？因为main.js 一定会运行，是入口文件，百分百会运行）。


## 什么是vue的数据响应式？

数据变化后，依赖数据的函数重新运行。