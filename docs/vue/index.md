> 学知识啊，往往是进5退1，甚至是进5退4，当你进行了一次冲刺后，你得停下来，打好地基，扎好营寨，才能进行下一步冲锋，你只管一股脑的往前跑，跑到最后，你会发现这路上发生了啥你完全不知道。你还得回到起点重写走一遍。所以说，我们需要有一些复盘，把之前写过的一些代码里面产生的各种问题，再来进行详细的解释

### vue在线挑战集合

一个Vue在线挑战集合，像刷Leet Code一样学习Vue

https://cn-vuejs-challenges.netlify.app/



## 模版到底是什么？

在这些诸多的问题里边，问题出的最多的就是这一块，就是“模版到底是个啥？”

```jsx
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>
```

如果你认为它是一个html 的话，那说明你在学习组件之前就出了很多问题，现在毒教材很多，受害者呢也很多，那么这个问题到底是啥呢？我首先请大家忘记之前学过的所有的vue，我现在给你下一个结论，你不能这些写。

![template](https://img.picgo.net/2025/07/26/image97e396121cc6546f.png)

我现在告诉你，做vue开发，你不能动```<div id='app'>```里的内容，你不能动这一块，这一块是vue要挂载的区域，它会把vue里边的界面，挂载到这个区域，简单来说就是替换，把vue生成的界面替换掉这个div，那么现在就出现了一个问题：替换成啥啊？你得告诉vue你到底要替换成啥啊，怎么告诉vue？

![render](https://img.picgo.net/2025/07/26/imagee3eb8503d6864c3a.png)

需要在vue配置里写一个render函数，这个render函数里边有个参数h，通过这个函数，你要返回一个结果，这个结果呢就是界面，那么vue到时候运行的时候，他就会调用这个函数，得到你返回的界面，然后用你这个界面去替换掉这个div，就这么简单。

![ui](https://img.picgo.net/2025/07/26/image75fe6e65fb5b4ad3.png)

但你要怎么写呢。你总不能直接自己手写个字符串吧，所以呢，这一块需要一个标准格式，vue能看懂的标准格式，那么这个标准格式怎么来的呢，就是通过参数h来生成，这个参数是一个函数，调用这个参数，可以生成一个对象，这个对象就是用来描述这个UI界面的，最终你需要把这个UI对象给返回.

那现在的问题是，调用这个函数的时候，我怎么告诉他我需要什么样的界面呢，他有这么几个参数：
1. 第一个是标签名
2. 第二个参数可以传一个对象，这个对象可以配置标签的属性等等
3. 第三个参数，你可以配置这个标签的子元素。子元素也是一个h函数


这个h函数看起来就有点类似```document.createElement```，我们看一下UI对象的打印结果就知道了。
![](https://img.picgo.net/2025/07/26/image4939e48f91e49797.png)

这个打印结果里边，它并没有打印出一个HTML元素，而是一个VNode对象，这只是一个**普通的JS对象**，这个对象里边有很多的属性，其中一个属性叫做tag，表示标签的名字，不管怎么样，这个对象，怎么看都不是一个dom元素，它只是一个**普通的JS对象**，我们把它叫做**虚拟dom**，他用一个普通的JS对象去描述界面，至于说vue为什么要这么做，是一些迫不得已的原因（个人理解最重要的原因是要支持跨端）。

但是我们注意到页面上最终生成出来的，确确实实是一个真实dom，你不能把对象显示到这，浏览器不认识啊，因此我们可以得出来一个结论：通过render函数返回一个虚拟dom，就是一个普通的js对象，把这个普通的js对象交给vue，然后呢vue把它变成一个真实的dom，然后把这个真实的dom替换掉挂载的元素，也就是这个div，这才是vue渲染界面的真正逻辑与流程，当然也只是一个非常简约的流程。

那接下来就好解释了，我们用h函数能不能去写界面？能写，写起来恶不恶心？恶心！所以呢，vue非常贴心的给你考虑到了，vue给你提供了一个template配置（字符串），这个字符串你可以按照一些特殊的语法来编写。那到时候，vue就帮你把这个玩意变成h函数，所以就不用再去写这个render了。但这个玩意只是为了让你写着方便的，最终其效果的还是render，只是帮你变成了render，这就叫**模版编译**。

![](https://img.picgo.net/2025/07/26/imageab33801ab59ee9f2.png)


甚至vue还支持你把模版写在html里（你要挂载的元素中），把这个元素的outerHTML字符串当做template，然后把这个template转成render。

所以说，我们在模版里写的这些语法，还有写的什么属性的绑定，还有写的什么事件，在真正运行的时候压根不存在，全是变成了render函数里的虚拟dom。

如果在工程化环境中呢，像这种sfc(单文件组件)里边的template是啥呢？还是一样的，只不过在工程化环境里，会直接在编译时直接就把模版变成render函数了（之前的模版编译发生在运行时，工程化时候直接在打包的时候就转换完了，性能更好，这种也叫做 **模版预编译**），最终还是要靠render起作用，从这个角度来看，不仅仅是模版，甚至一个组件，一个sfc，本质上也是普通的JS对象。

好，到现在，相信读者已经搞清楚了模版、render、虚拟dom这些的基本含义了，这对于理解后边的很多知识都是非常重要的。


## 全局注册 vs 局部注册

我们的代码是分散的，分散到不同的模块里边，最终一打包，就会变成一个文件，所有的模块都会变成一个文件。

![nHhmU.png](https://i.imgs.ovh/2025/07/28/nHhmU.png)

如果你这样的话，其实全局和局部注册没什么区别。

当你的项目上了一定规模之后，我们很有可能不希望打包成一个文件，我们需要分包。

那这样一来，如果你是局部注册的，就不会有问题，但如果你是全局注册的，全局注册的这些组件都是在main.js里注册的

（这里为什么一定要在main.js 注册？因为main.js 一定会运行，是入口文件，百分百会运行）。


## 什么是vue的数据响应式？

数据变化后，依赖数据的函数重新运行。