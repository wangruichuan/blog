## MCP是个啥？(TODO)

### 初步了解

全称：模型上下文协议 AI Agent Claude公司推出的

mcp是注册在类似cursor的编辑器（AI工具）上的

类似于 OpenAI 的 function calling

cursor最基本的模式就是问一句答一句，然后答的时候还可以帮我修改代码。

比方说我问他今天天气怎么样，这个AI是不能回答我的，因为AI是基于以前的数据，对于今天的数据它是不知道的，这个时候我就可以给他一个MCP，比方这个MCP给他提供了一个能力，比方说这个能力查询当天的天气。

AI会根据自己的思考，会去判断我应该在什么时候去调用哪个MCP，去获得它想要的东西。这时候我再去问他今天天气怎么样，就会通过MCP的一个接口去调取当天的天气，然后通过这个MCP的答案来回答我。可以把AI理解成前端，mcp理解为后端给你的接口，AI要实现一个功能的话，它就会自己去思考我需要去调用后端的哪个接口才能完成这个功能，这就是MCP。

实际操作起来，就是你给它提供一个方法，这个方法你规定一下入参，然后在这个方法里面你做什么事情随便，你可以去请求些接口，但是你只需要返回一段文本，最终AI会根据你的问题和MCP返回的文本去给出答案。

在写这个MCP的时候，你会写一下这个MCP它是干什么的，会有个固定的格式，来告诉每个mcp的作用是啥。

> 就这么说吧，你用 HBuilderX 开发App，代码让AI 修改，但是呢AI改完之后又不知道运行的结果对不对。需要有一个东西告诉AI，去读 HBuilderX 下的哪个文件得到 App运行后的日志，让 ai 改完代码知道改的对不对.这就是本质。 
>  首先输出格式是什么样，在哪里获得…
> 
>  比如ps或者剪映有了mcp，你就可以直接让ai来操作这些软件，帮你p图，剪视频
> 
> 在function calling时代，假设服务器（也称为agent）使用openai家的大模型，openai自己规定了一套fc格式，那服务器提供的工具都必须遵循它的格式，假设写了10个工具（可以简单理解为函数），现在openai突然不提供api了，只好去用claude家的模型服务，结果claude家的fc格式与openai家的不一致，这下服务器就得重写这10个工具函数，扩展一下，设模型商家为n个，工具函数m个，那服务器就得预先写mn个，并且这个m和n都是变化的值，就需要不断修改服务器编写的代码。
> 
> 你可能会这样解决这个麻烦:服务器写一个转换函数来统一适配这些模型要求的格式，比如:const  格式 = 转换函数（工具），这样就减轻了编写好几套工具的问题。但是这依然存在问题，转换函数的内部实现会变得异常复杂，因为每个工具函数的返回值数据格式，传入参数都不一致，即使当下适配完了，后续出来新模型新工具，又得在转换函数里不断调整。
> 
> function calling是什么，其实是大模型没有记忆能力。
> 比如用户问明天北京天气怎么样，由于大模型没法预测，所以服务器除了将用户的提问传给大模型，还会传递一个信息 : 调用一个叫getWeather的函数就能得到天气，这就是所谓的tool。
> 
> 有个明显的问题，如果大模型返回一句“调用getWeather函数”的文本，服务器是很难分析的，因此会在prompt中写好一些规则，比如大模型预调用某些能力，就返回json:{
> “toolName”:欲调用的工具函数名
> }
> 服务器解析json是很好解析的。
> 
> 但是这样依然存在问题，**大模型并不是每次都按照要求的格式回答，即使10000次内出错一次，那也无法接受，使用prompt来约束终归有限**。
> 
> 只有研究模型的厂家深度调教才行。因此各个模型厂商都制定了一套function calling标准，这个标准规定了tool的规范，返回的格式，这样就很大程度的避免了模型乱回的问题


## Vibe Coding