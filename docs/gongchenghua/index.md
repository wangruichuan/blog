## 为什么需要构建工具？Webpack入门

为什么需要构建工具？本质上就在于，人喜欢的代码和运行环境喜欢的代码，它就不一样

![image](https://img.picgo.net/2025/07/27/imagefc52334dfbc8ab68.png)

左边是我们人喜欢的代码，我们喜欢把代码分成多个模版方便关联，喜欢使用预编译器来书写更加简洁优雅的css代码和一些前沿的api等等。但是这些玩意浏览器是不喜欢的，浏览器喜欢的文件更少，喜欢纯粹的css代码。那么就需要有一个东西，让我们舒舒服服的写代码，然后经过这个东西，把它转化成运行环境里边喜欢的代码，那么这个转换的过程，就是构建工具打包的过程，具体来说在我们写代码的时候，有了webpack，我们就可以在src目录里边舒舒服服用我们喜欢的方式来书写代码，然后经过一个命令来打包变成浏览器喜欢的代码。

这里介绍几个webpack自身的核心能力：

### 打包压缩

首先我们来看打包压缩，对于我们写的源代码，并不能直接运行。我们必须进行打包，变成运行环境喜欢的代码。 
![nFumF.png](https://i.imgs.ovh/2025/07/27/nFumF.png)
这里分别展示了css的源码与打包后的结果，我们发现，去掉了空格、换行
  
对于JS来说，源码里的js是规规矩矩的，该换行的时候换行，变量啊函数啊都是标准命名的，但是你看打包结果的js，变量变成了单字母，回车空格全没了。那这个过程就叫做**代码的压缩与混淆**。

这些事情，是webpack自动完成的，所以说webpack的第一个功能，就是打包压缩。

### 文件指纹

![nSyQ0.png](https://i.imgs.ovh/2025/07/27/nSyQ0.png)

第二个功能叫做文件指纹，我们观察到，打包的结果里边，无论是css还是js，都带上了这么一串这个玩意，那么这个玩意是啥呢？这个玩意我们把它成为“文件指纹”。本质上就是hash的前几位，它的特点是根据你源代码的内容不同而不同，你源代码的内容没变化，那么这个值就没变，只要你改了源代码，重新打包就会变化。

这样做有什么用呢？这就要谈到我们过去前端开发过程中一个非常麻烦的问题，缓存问题：
假设我们没有这种文件指纹，就是一个规规矩矩的文件名，那么就会造成一个问题，当浏览器第一次去请求js文件时，浏览器会把这种资源文件缓存起来，缓存的好处是减少网络传输，当下一次再需要这个js的时候，它就直接去缓存里边拿了。这就导致如果服务器更新了代码，浏览器它不知道，它仍然从缓存去拿。这时候文件指纹就起作用了，第一次请求的时候，这个文件是有指纹的，服务器给了我们这个带有指纹的文件内容，将来服务器有更新，更新过后文件指纹是不是变了，那么于是将来的页面，它就会去请求新的js文件，而这个文件和缓存的js文件不一样，会重新去请求服务器，拿到最新的js文件。

```TODO``` 以后会补充下详细的浏览器缓存机制

### 开发服务器

我们使用构建工具去开发的时候，写了一段代码，我们要怎么运行呢，按照正常的做法是重新打包，再去运行打包后的结果，但是这样子确实太麻烦了，有没有什么办法一边服务器一边看最新效果。webpack提供了一个非常简单的服务器，我们不需要任何配置，启动服务器以后，你写完代码以后保存，浏览器立即刷新。

在这个阶段，webpack并不会形成打包结果文件，而是把打包的内容放到内存中，当我们请求服务器时，服务器从内存中给予我们打包结果。

与此同时，当源码发生变动时，webpack会自动重新打包，同时刷新页面以访问到最新的打包结果。


![nSvRx.png](https://i.imgs.ovh/2025/07/27/nSvRx.png)


## 静态资源处理

对于前端新手来着，相信大家一定会被各种路径问题搞疯掉。

比如说，我这个资源文件明明放到css目录里边，但是它偏偏就不认这个css目录，非得说在根目录中找不到图片；我的首页怎么又又又白屏了，这次我尝试把知识梳理下，看看能不能让这个困惑少一点。

当然，我总觉得要把这些完全搞清楚，要懂一些运维和OS的知识，我只能站在前端角度去理解这个问题。

### 绝对路径 vs 相对路径

无论是绝对和相对，其实目标只有一个，得到一个完整的url地址。即便你写的是相对路径 ```./a/b.css```，浏览器会给你进行一个自动的转换，```http:域名:端口号/a/b.css```。

而绝对和相对，其实就是转换方式不一样。

绝对路径有这么几种写法：
1. 完整URL
2. 省略掉协议 ```http://localhost:5500/a/b/c```  => ```//localhost:5500/a/b/c``` 自动补全协议，这个其实很有用，比如你在本地用的http，生产里用的https
3. 省略掉域名和端口：```/a/b```  => ```http://localhost:5500/a/b``` 省略路径，把域名和端口补全

为什么把这三种叫做绝对路径呢，因为这三种方法生成的url地址，它跟当前页面的path部分，没有一点关系

相对路径：
1. 直接书写：```a/b.css``` 等于 ```./a/b/css```
2. ./开头：例如：./1.png 相对的是 当前path：```http://localhost:5500/a/b/1.png``` ==>  ``` http://localhost:5500/a/b/c/1.png```

可以看出，相对路径是跟当前路径的path部分是关联的。


### 静态资源的动态加载 
![](https://pic1.imgdb.cn/item/68885a7c58cb8da5c8eaba5a.png) 

假如说我想实现，点击一个tab，背景图更换，但是这个背景的静态资源是在我们的assets目录下的

![](https://pic1.imgdb.cn/item/68885a2958cb8da5c8eaba20.png)

那也就是说，啥意思呢，你选择的这个东西啊，我只要稍微拼接一下，就可以拼接成一个路径，我把这个路径放到一个字符串里边，放到一个响应式路径里边。那这样一来是不是简单了。

但是，你会发现出问题了，背景图片加载不出来，这就是 ``` 静态资源的动态加载```  问题。

我们打开控制台，找到相应的背景图片最终的路径是什么？

![](https://pic1.imgdb.cn/item/68885b7258cb8da5c8eabb55.png)

这里写的是一个相对路径，那再去来看一下打包目录：

![](https://pic1.imgdb.cn/item/68885bd158cb8da5c8eabb7a.png)

按理说，这个图片是不是应该到这个assets目录下边去找。但我们发现打包后的assets只有一个js和css

诶，不对啊，我图片呢？我图片跑哪了？？我们发现，我们src下的图片根本没有形成打包结果，那打包结果里都木有图片，那肯定找不到图片。


接下来就是需要分析原因了，为啥图片过不去。我们来捋一捋

目前是使用的vue3开发，vue3使用的是vite。vite在打包的时候，会去做 依赖分析，分析每一个模块它里边依赖了那些模块，但是我们整个vue组件里边没有任何组件去引用图片这个模块。那么它就把这个模块排除出去了。这就是原因。

那有同学说，那不对啊。我有时候在template这样使用 ```<img src=“./logo.png”>``` 他也不报错啊，我应该可以正常请求到图。我寻思也没导入啊，那为啥会到这个打包结果里呢？

这是因为，在vite里，他有一些 **自动依赖发现**：尽管你没有明显的使用import语句去导入，但是构建工具通过分析你的代码，它能够发现这些依赖，但是自动发现依赖 不是万能的，他只有在一些特定的场景下才会生效：

1. 多媒体元素的静态链接：不仅要有链接，而且必须是静态链接![](https://pic1.imgdb.cn/item/68885dbe58cb8da5c8eabc18.png) 一旦换成动态之后，直接会懵逼。那为什么必须是静态链接？因为依赖分析的时候是编译时态，都没运行，它咋能知道这个变量的值是啥啊。
2. 样式中的静态链接 ![](https://pic1.imgdb.cn/item/68885e3958cb8da5c8eabc6f.png)
   
![](https://pic1.imgdb.cn/item/68885fef58cb8da5c8eabdbe.png)

而且这里的路径，自动帮你替换成了打包后的路径。我们发现，它会自动的形成依赖，并完成替换。
   
3. 动态导入语句中的静态或半静态链接
  **动态导入语句**：```import('')``` 这里你可以写一个半静态的链接，就是你可以用一个模版字符串来拼接，这个拼接里边，你不能全是变量，比如你在模版字符串里边直接放了一个变量，那肯定不行。
  但 ```import(`./assets/${val}.jpg`)``` 这样可以。你会发现打包结果里，不仅有图片，每张图片还会带一个js
  ![](https://pic1.imgdb.cn/item/6888612058cb8da5c8eac4cf.png)

4. URL构造器中的静态or半静态链接。



那怎么办，我们要是就需要动态链接呢？这里提供几种方法：

1. 直接放public目录：public目录下的文件会原封不动的被复制到打包结果的根目录里边。但这样做其实不好，因为你这样做后，就丢失了文件指纹了，而且有一天，如果我不再依赖这些资源，我必须去手动删除这些资源，其实算不上一种好办法。
2. 手动导入：我一个一个的把这些资源全部导入。算了吧，不用这种方式的懂的都懂，除非你的资源个数很少。
![](https://pic1.imgdb.cn/item/68885f8458cb8da5c8eabd83.png)
3. 使用上述的第3种方法：动态导入+半静态链接。
   有两个问题：①就他为什么这样子做是可以的？②打包后的生成的js是干啥用的，为什么需要？

   如果说你有这样的问题，说明，你的思维还是很缜密的。
   首先是第一个问题：它怎么知道这个值是多少啊？
   答案是啥呢？答案是他不知道，真的不知道你的变量的值是多少，那不知道怎么办，好就好在，这是一个半静态的逻辑，他知道这一部分一定是固定，于是它就做了这么一个处理：把./asstes目录下的所有的东西全部形成依赖，我不管你用哪一个。 
   第二个问题的应用场景是什么？我们在这里动态导入之后，我们如何拿到打包结果里边的那个静态资源路径，这就需要靠对应的js了，你看这个js，它的到处其实就是这个动态导入。因此我们这里可以这样拿到打包后的路径：

![2cyHX.png](https://i.imgs.ovh/2025/07/29/2cyHX.png)

路径完全正确，并且还附带有文件指纹。

4. URL构造器中的静态or半静态链接。
   ![](https://pic1.imgdb.cn/item/6888644e58cb8da5c8eadda1.png)
   import.meta.url ：相对当前模块的路径

此时，最终生成的js文件是没有了，但我们可以应该这个url对象，拿到一些信息，这个对象里边有一个pathname属性，这就是打包结果里边的路径信息

![](https://pic1.imgdb.cn/item/688864bb58cb8da5c8eae155.png)


这样呢，就完成了资源动态引入的问题。


## 模块化

### 引言

#### 什么是模块化？

- 每个文件就是一个模块，模块中的数据是私有的，模块之间相互隔离
- 可以通过一些手段，把模块内指定的数据交出去，供别的模块使用

#### 有那些标准

- CommonJS
- ES6 模块化
- AMD CMD

### CommonJS

![](https://pic1.imgdb.cn/item/68896b6d58cb8da5c8ee4f95.png)


![](https://pic1.imgdb.cn/item/68896b8058cb8da5c8ee5018.png)

当我们使用一个模块的导出结果时，需要使用一个require函数，里面传入路径，这个函数一运行，相当于运行这个模块，并有个函数的返回结果，也就是这个模块的导出结果。

所以，理解CJS，必须要知道require函数。这个函数是node在本地实现的，这个模块接收一个路径参数，实际上做了这么几件事：

1. 根据传递的模块路径，得到模块完整的绝对路径，获得一个唯一的模块id` moduleId`
2. 判断缓存：根据id判断有没有缓存，之前有没有运行过，之前运行过的话，直接拿之前的。require函数这里就结束。
3. 真正运行模块代码的辅助函数：把你模块里的代码放到一个函数里面。也就是意味着你在模块里的代码，实际上是在一个函数的环境里边，可以通过打印arguments查看
   1. 这个辅助函数有五个参数：
      1. exports:这就解释了为什么我们在模块里可以直接使用exports，因为它就是一个函数的参数啊。
      2. require
      3. module
      4. __filename：得到这个模块的绝对路径
      5. __dirname：得到这个模块目录的绝对路径
4. 准备辅助函数的所需参数
   - moudule对象：
   ```javascript
   var moudule = {
      exports: {},
   }
   ```
   - exports对象：
   ```javascript
   var exports = moudle.exports
   ```
   - __filename：moduleId模块id
   - __dirname：mouduleId模块目录
5. 运行这个函数：这里是通过call去调用的，this绑定的是exports对象
6. 缓存模块：缓存module.exports对象
7. 返回 module.exports

那，接下来做下这道题吧！看看下边的这个模块的导出内容是什么

![](https://pic1.imgdb.cn/item/68970e3858cb8da5c81490ca.png)

#### 导出数据

有两种方式：

- ```module.exports = value``` 
- ```exports.xxx = value ``` 
  
![](https://pic1.imgdb.cn/item/68896c0358cb8da5c8ee5388.png)

#### 导入数据

![](https://pic1.imgdb.cn/item/68896c4858cb8da5c8ee5554.png)


### ESMoudule

![](https://pic1.imgdb.cn/item/68896ca858cb8da5c8ee57d0.png)

#### 导出数据

1. 分别导出
   
   ![](https://pic1.imgdb.cn/item/68896cdc58cb8da5c8ee592f.png)

2. 统一导出
   
   ![](https://pic1.imgdb.cn/item/68896cf358cb8da5c8ee5943.png)

3. 默认导出
   
   ![](https://pic1.imgdb.cn/item/68896d0b58cb8da5c8ee5944.png)


「上述多种导出⽅式，可以同时使⽤」

#### 导入数据

1. 导入全部
   
   ```import * as school from './school.js'```

2. 命名导入

   ```import { name,slogan,getTel } from './school.js'```

   ```import { name as myName,slogan,getTel } from './school.js''```

3. 默认导入
   
   ```import school from './school.js'```

4. 命名导入与默认导入混用：默认导⼊的内容必须放在前⽅

   ```import school, { name,slogan,getTel } from './school.js'```

5. 动态导入：允许在运⾏时**按需加载**模块，返回值是⼀个 Promise。

   ```import('./school.js').then((school) => { console.log(school.name) })```

   ``` const school = await import('./school.js'); ```

6. import 可以不接收任何数据：例如仅仅只是让 mock.js 参与运行

   ```import './mock.js'```

#### ESModule工作原理（限定 浏览器）

1. 模块解析：
   1. url地址补全
   2. 下载相应的模块
   3. 找到模块代码里所有的顶级导入语句
      1. 顶级：写在全局的（没有写在各种循环，判断里的）
   4. 进一步解析其他模块
2. 模块执行：
   1. 是如何处理导出语句的:内部会生成一个映射表，专门记录这个模块
   2. 将导出的放到标识符中（**符号绑定**）：这个现象是绝无仅有的,在我们学习js时
   3. 运行动态导入语句：动态导入是在运行期间来处理的：异步下载js，然后可以在promise里拿到这个表格对象，你可以直接打印这个表格
   
   ![](https://pic1.imgdb.cn/item/688973c058cb8da5c8ee7988.png)

#### 符号绑定

先说结论，只要导出的数据，一定要用const

来看场景：

```javascript
export let count = 0
export const increment = () => {count++}
```


```javascript
import {count,increment} from './count.js'

```

这里要考虑几个问题：
1. import {count,increment} 的count是常亮还是变量？常量，如果你尝试去count++会发现直接报错
2. 但是如果我们去调用increment函数执行以下，再次打印count会发现居然变了，这是最诡异的一点，这个玩意就叫做符号绑定（同一块内存空间上，它拥有两个符号都指向它）
   ![](https://pic1.imgdb.cn/item/688b0b7758cb8da5c8f40fc1.png)

   引用和引用传递：只在argument和import会出现引用传递

   https://v.douyin.com/6YBwit-RPko/ 


```javascript
function count (){
 let sum = 1
 function increment(){
 sum += 1
 }
 return {sum,increment}
}
const {sum,increment} = count()
console.log(sum)
increment()
increment()
console.log(sum)


// 输出 1 1
```

```javascript
let sum = 1
function increment (){
 sum += 1
}
module.exports = {sum,increment}


const {sum,increment} = require('./count.js')
console.log(sum)
increment()
increment()
console.log(sum)


```


```javascript
let sum = 1
function increment(){
 sum += 1
}
export {sum,increment}

// 符号绑定
import {sum,increment} from './count.js'
console.log(sum) //1
increment()
increment()
console.log(sum) //3

//使⽤原则：导出的常量，务必⽤ const 定义
```

### node中的模块查找方式

当你的代码里，无论使用了require还是import，node是如何根据传入的路径，准确的找到你的这个模块文件的？

1. 文件的查找：以./ 、../ 或者 / 开头的时候，进入文件查找的逻辑：看你的这个文件是否存在。如果不存在：
   1. 补一个js，看你补完后缀后存不存在
   2. 补一个json。
   3. 如果还找不到，就会走 文件夹查找 的逻辑。
2. 文件夹的查找：找到一个文件夹后，会走到这个文件夹的根目录下边，看有没有package.json，并且看一下这个文件的配置里边有没有一个字段叫做  main，如果有就读取到这个main字段对应的js文件。
   1. 如果说：①没有这个配置文件②没有这个字段 ③这个字段里对应路径的文件没有找到。
   2. 直接去看这个文件夹下边有没有一个文件叫做 index.js 或者 index.json
3. 内置模块: 如果你是直接书写，那你会判断你书写的模块是不是内置的模块，像fs，path，http，那就直接拿给你，如果不在，就会被认为是第三方的模块。
4. 第三方模块:会去当前目录下的node_modules目录中去找，如果当前目录没有，会依次往上层目录里去找，直到找到我们磁盘的根目录。需要注意的是，在进入node_modules后，又会进入 这种 文件/文件夹 查找的模式

## pnpm + monorepo （待完善）

### 为什么选择pnpm？

一个词：性能！

- 软链接：类似于windows中的快捷方式。在你用的这些包里，通过软链接去链接到你的项目，项目在装依赖的时候，会装到一个集中仓库，去集中仓库中去查找依赖。通过链接机制高效集中的将依赖管理起来。
- 缓存机制、拍平结构、磁盘占用小
- 原生支持workspace模式
  
中心化思想解决依赖复用问题

### Monorepo

重复带来低效，复杂使人难以理解

#### 传统仓库存储的问题

1. 代码复用：我们很常见的一种方式就是我写个npm包发布，然后引入到项目里。但是这样有一个问题就是很麻烦，如果说我就改动一点，就要走上一堆流程，复用开发调试的成本是很高的。
2. 版本管理：当某个底层的工具包发布了这种break change，那么这个包下的所有项目都要去更新，那么这个更新过程就会很麻烦。
3. 项目基建：传统多项目管理下，各个项目它的工作流是割裂的，每个项目你都需要单独配置，它的开发环境，CI,部署和发布...主要还是学习成本，每个项目的这种基建搭建，用到的底层的脚手架之类的工具。
   

## 微前端

微前端是一种将大型应用拆分成小型单元的架构模式。

通俗来说，就是在一个web应用中，可以独立运行另一个web应用，常见的场景有：做一个企业管理系统，把这个已有的采购系统接入到这个平台；又或者说，一部分用vue开发，另一部分用这个react。

微前端的框架通常具备以下能力：
1. 子应用的加载和下载的能力
2. 子应用路由状态保持的能力
3. 应用间通信的能力


为什么不用iframe？

1. 路由状态丢失：刷新一下，iframe的url状态就会丢失
2. dom割裂严重：弹窗只能在iframe内部展示
3. web间通信困难


主流方案：**single-spa、qiankun、无界**

## Chrome DevTools

https://www.bilibili.com/video/BV18tM7ziEYv/

### Proformance选项卡

https://www.bilibili.com/video/BV1cLdZY5Eqh/

### Sources选项卡

https://www.bilibili.com/video/BV1kMZ1Y7EWC/

