## 动态规划
### 基础知识
在所有的算法题中，公认最难的永远是动态规划，你可以看下力扣里面，基本上是属于困难和中等，很少遇到简单类型，那我们在这块就是要解决动态规划。
> 顺便说一下，目前在整个软件开发领域里边，都2025年了，居然还存在一种思想，认为这个算法无所谓的，平时开发又不怎么用，但我觉得，这种思想的生存空间会越来越窄。这里直接下一个死结论：你不会算法，在这个行业里，要么走不长，要么走不好，有的时候，两者皆有。
> 为什么，程序的本质是什么？为了解决一个需求而去寻找实现它的方法吗。这不是算法这是啥啊。可以说，算法就是对整个程序的高度浓缩。你能搞定复杂的算法问题，就一定能搞定复杂的业务问题！

解决动态规划问题，就两个步骤：
1. 思路
2. 实现

一定是先想好了思路，再去实现，这不仅仅是解决动态规划的一个流程，而是所有的算法题，甚至所有的需求实现都应该如此，那么在这两步中，最难的就是思路了。

那么解决动态规划问题，需要使用一种什么样的思路来解题呢？最难的一个点：**确定状态转移方程**
> 什么是状态转移方程？答：不同规模的相同问题之间的关系。

这里来看一个具体的例子：

比方说动态规划里的入门题是什么：斐波那契数列。

1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765...
除了前两位固定为1之外，每一位实际上等于前两位之和。比方说让你求一个斐波那契数列第N位的值，我们用一个函数f(n)来表示：那这个n就表示的是问题的规模。n越大，问题是规模越大。比方说，f(5)表示的是斐波那契数列的第5位。这些不同规模的相同问题，他们之间的关系就是状态转移方程。
就是  **f(n)=f(n-1)+f(n-2)**

然后就是确定一些特殊解，f(1)=1,f(2)=1。

我们把这个 f 通常叫做 dp (dynamic programming) 动态规划，大家不用理解这个动态规划这个词到底是什么意思，它解题的本质就是这样，甚至对于很多题，你只要列出一些方程，代码都出来了，来吧，比方说我们就求一个斐波那契数列。

```javascript
function fib(n) {
    if (n <= 2) return 1;
    return fib(n - 1) + fib(n - 2);
}
```
当然这个斐波那契数列，它是把它的状态转移方程直接拍你脑门上了，你一眼就看出来了，但大部分情况可能没有那么容易看出来，这就需要去思考去寻找了。

比方说经典的 **青蛙跳台阶问题** ：
![guagua](https://img.picgo.net/2025/07/25/image1a6cdfd57fd9c8d2.png)

有n级台阶，有这么一个青蛙，他可以一次跳一阶，也可以跳两阶，问他从台阶底部跳到达台阶的顶部，一共有多少种跳法，这也是一个动态规划的问题，只不过这个问题呢，没有那么容易的看出它的状态转移方程。

我们假设有这么一个函数，表示的是青蛙从底部跳到n级台阶，一共有多少种跳法。
dp(6)就表示青蛙从底部跳完六级台阶，一共的跳法数量，dp(5)就表示青蛙从底部到第五级台阶，一共的跳法数量。

他们之间有没有关系呢，可以看到。跳完六级台阶，无非就两种情况，就是最后一步跳两阶和最后一步跳一阶，那我只要找出跳到这有多少种跳法，那么最后跳一步的情况就有多少种。比方说，在最后只跳一步的前提下，有1000种情况，最后跳两步的情况下有500种情况，那么于是，dp(6)就应该等于dp(5) + dp(4) --> 最后只跳一阶的情况+最后只跳两阶的情况，状态转移方程就出来了，我们发现，居然还是斐波那契数列，但这一次的斐波那契数列是我们通过分析得出来的，而不是一眼就看出来的，这就是解决动态规划问题的最困难的地方，虽然困难，我们也有专门的训练方式，以及这里边有一些找到状态转移方程的技巧。

### 背包问题
> 01背包问题他是一个守门员，就是说，你如果过了它，就拿到了去力扣上做动态规划题的入场券，如果你过不了，那我就不建议你去力扣刷题。为啥呢，不说你能不能写出来了，你就是直接看题解你都不一定看得懂。

![bagpack.png](https://i.imgs.ovh/2025/07/25/We67h.png)

这个问题怎么说的呢？就是说给你一些物品，数量是任意的，每件物品呢有它的价值和重量，让你在这些物品里选一些，放入一个背包，这个背包他有一个支持的最大重量，你不能超过它，请问我该如何选择，才能够使利益最大化，让你求出那个最大的价值。

整个问题里，有三个维度：价值、重量、背包的容量。三个维度往往可以构建出一个二维表

![二维表](https://i.imgs.ovh/2025/07/25/WeeJa.png)

每一个格子就是一个dp[i][j],比方说 dp[3][5]它表达的意思就是 在物品下标在0~3的情况下，在这些物品当中，选择重量不超过5的物品，所得到的最优解。

如果说我能填完整个dp表格，那你想一下，这个表格的最后一个格子，它表达的是总重要在6的情况下，0到4的物品区间内能拿到的最优解，不就是我们的最终结果吗。那接下来我们就需要分析，这每一个格子是一个局部问题，它的局部问题到底应该怎么解出来。比方说这个格子，其实他只有两种情况：这件物品选还是不选。是不是就这两种情况，我要在选和不选里边找一个最优解，那么这个表达式就应该写成这样：dp[i][j] = max(选第i件物品，不选第i件物品)

- 不选第i件物品：最优解为 同等重量下，前边这些格子的最优解，也就是dp[i-1][j]，也就是上一行的相同列
- 选第i件物品：关键就在于选这件物品，选这件物品比较复杂。如果说我选了这件物品，那么这件物品呢有它自身的价值，所以说选这件物品的情况下，一定要把这个值给考虑进去。因此，表达式里边至少其中有一段可以写成value[i],但是光有它还不够，因为你选了它之后，可能还有剩余的空间，比方说我这个空间呢占了4，总空间是5，5-4是不是还剩余一些空间，剩余空间是1，那么我们就要得到在这个空间下前边这一部分的最优解，再给他加上不就完事了，那前边的最优解是啥呢。不就是dp[i-1][j-w[i]]吗（j - 重量这一列），然后最终的状态转移方程就列出来了。
   
    ``dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])``

最难的部分就结束了。

剩下的无非就是一些边界情况了，比方说，有可能呢当前的格子本身就装不下，那直接就不选就完事了。

还有就是第一行的时候呢，由于它没有上边这一行，只看它自己重量能不能放进去，能放进去就放进去，这里把填完之后的表格给填一下。
![填完之后的图片](https://i.imgs.ovh/2025/07/25/W90xm.png)

这个问题貌似就解决了，现在呢我们要考虑一下效率了，用这种方案的话，它的空间复杂度是多少？O（n*bagWeight），能不能优化呢?

我们观察到，在每一行运算的时候，我们其实只需要上一行结果，所以，我们可以用一个一维数组（滚动数组）来代替二维数组，空间复杂度降为O（bagWeight），时间复杂度不变。
``next[j] = max(result[j], result[j-w[i]] + v[i])``


那么好，这里直接给出最终的代码：
```javascript
function package01(bagWeight, value, weight) {

    let result = []
    for (let j = 0; j <= bagWeight; j++) {
        result[j] = j >= value[0] ? value[0] : 0
    }
    for (let i = 1; i < value.length; i++) {
        const next = []
        for (let j = 0; j <= bagWeight; j++) {
            if (j >= weight[i]) {
                next[j] = Math.max(result[j],
                    value[i] + result[j - weight[i]]
                )
            } else {
                next[j] = result[j]

            }


        }
        result = next
    }
    return result[bagWeight]
}

const result = package01(6, [5, 10, 3, 6, 3], [2, 5, 1, 4, 3])

console.log(result);

```

这道题非常具有借鉴意义，难度适中，搞清了很多题，力扣上的很多的动态规划问题，不能说做不出来，至少它的题解你就能看懂了。

### 最优解问题
动态规划里最常见的一个问题就是求一个最优解。这里看一个 打家劫舍 的例子。至于它罗里吧嗦的描述呢，我就不一一念了。就是说，给你一个数组，这个数组里边，每一个数字他一定是大于等于0的，然后希望你从数组里边取出数字，问你取出的所有数字相加之和，它的最大值是多少，那么在取的时候，有一个规则，就是 **相邻的两个数字是不能取的**，比方说把数组 [1,2,3,1] 拿过来，你只能取 1 和 3，不能取 1 和 2，不能取 2 和 3，不能取 3 和 1。只要不相邻就可以取出来，问取出的总量的最大值为多少，那么像这个问题呢，最优解就是4，可以取1和3。这就是一个求最优解的问题。

面对这种求最优解的问题，他往往的特点是什么呢？就是这个问题的整体上，它的情况非常之多，你很难从一个整体上能够迅速的抓到他的逻辑和规律，就是整体上他很复杂，但是往往在局部上他是非常简单的，我们来看一下吧。

![最优解问题](https://img.picgo.net/2025/07/25/imageb72ab1c841f5983b.png)

它给了你一个数组，这个数组里边有各种各样的数字，你要整体去求就比较麻烦，但是你想一想局部呢，比方说我们定义一个dp[i],这个dp[i]表示什么意思呢，他表示说从数组的下标0开始，到下标i之间，在这个范围内我找一个最优解，那么这就是一个一般性的解。一般性的解解出来了，那么整个全局的解我一定能解出来，为啥呢，因为我无非就是让i等于数组的长度-1不就行了。

好，那么这个整体的问题呢，就变成了一个局部的问题了，整体的问题可能比较复杂，但是局部问题往往是很简单的，我们就来观察一下这一部分，他要找到最优解该怎么去找，无非就两种情况：i这个位置我要不要。在这两种情况，我取一个最大值不就完了吗，所以这个表达式应该写成什么样子呢：
dp[i] = max(i要取，i不取)
- i要取：i要取的话，i-1这个位置就不能取了，这个位置的表达式就是 nums[i]+前边的最优解(dp[i-2])
- i不取：i不取，那么表达式就是dp[i-1]

最终的状态转移方程就是：

``` dp[i] = max(dp[i-1], dp[i-2] + nums[i]) ```

考虑几种边界情况：
- i=0时：dp[0] = nums[0]
- i=1时：dp[1] = max(nums[0], nums[1])

好，给出最终的代码：

```javascript
function rob(nums) {
    if(nums.length === 0){
        return 0
    }
     if(nums.length === 1){
        return nums[0]
    }
    const dp = [];
    for (let i = 0; i < nums.length; i++) { 
        if(i===0){
            dp[i] = nums[i]
        }
        else if(i===1){
            dp[i] = Math.max(nums[i],nums[i-1])    
        }else{
            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1])
        }

    }
    return dp[nums.length-1]

}

console.log(rob([1,2,3,1]))

```

更新于2020/05/10 23:49:52